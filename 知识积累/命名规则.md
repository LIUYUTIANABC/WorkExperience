# 全局变量和命名规则

- [全局变量和命名规则](#全局变量和命名规则)
  - [不要再祸害C语言了！滥用“全局变量”的后果居然如此严重？](#不要再祸害c语言了滥用全局变量的后果居然如此严重)
    - [参考网址](#参考网址)
    - [重点总结](#重点总结)
      - [变量介绍](#变量介绍)
      - [新手常犯的错误](#新手常犯的错误)
      - [不能使用全局变量，那编写程序的对策](#不能使用全局变量那编写程序的对策)
      - [大量使用局部变量也会容易造成栈溢出](#大量使用局部变量也会容易造成栈溢出)
  - [volatile static 用法](#volatile-static-用法)
    - [参考网址](#参考网址-1)
    - [注意问题](#注意问题)
      - [static 用法](#static-用法)
      - [volatile 用法](#volatile-用法)
    - [一个参数既可以是const还可以是volatile吗？](#一个参数既可以是const还可以是volatile吗)
      - [const 介绍](#const-介绍)
      - [const 和 define](#const-和-define)
  - [命名规则](#命名规则)
    - [常用方法](#常用方法)
    - [命名](#命名)

## 不要再祸害C语言了！滥用“全局变量”的后果居然如此严重？

### 参考网址

- <https://www.eet-china.com/mp/a14609.html>

### 重点总结

#### 变量介绍

|              |                                                        |
| ------------ | ------------------------------------------------------ |
| 全局变量     | 所有文件都可见，外部文件用 ‘extern’ 声明， 存储在 SRAM |
| 局部变量     | 仅在进入函数体内可用， 退出后空间收回， 存储在栈空间   |
| 静态全局变量 | 仅在本文件可以使用， 其他文件不可访问， 存储在 SRAM    |
| 静态局部变量 | 仅在进入函数体内可用， 始终保存， 存储在 SRAM          |

#### 新手常犯的错误

> - 最易范的错误是全局变量满天飞， 这帮家伙几乎把全局变量当作函数形参来用.
> - 由于软件的分层不合理，到了后期维护，哪怕仅是增加修改删除小功能，往往要从上到下掘地三尺地修改
> - 全局变量大量使用，少不了有些变量流连忘返于中断与主回圈程序之间。这个时候如果处理不当，系统的bug就是随机出现的，无规律的

#### 不能使用全局变量，那编写程序的对策

> - 能不用全局变量尽量不用
> >
> > - 我想除了系统状态和控制参数、通信处理和一些需要效率的模块，其他的基本可以靠合理的软件分层和编程技巧来解决
>
> - 如果不可避免需要用到，那能藏多深就藏多深。
>
> > - 1)如果只有某.c文件用，就static到该文件中，顺便把结构体定义也收进来；
> > - 2)如果只有一个函数用，那就static到函数里面去；
> > - 3)如果非要开放出去让人读取，那就用函数return出去，这样就是只读属性了；
> > - 4)如果非要遭人蹂躏赋值，好吧，我开放函数接口让你传参赋值；
> > - 5)实在非要extern我，我还可以严格控制包含我.h档的对象，而不是放到公共的includes.h中被人围观，丢人现眼。

#### 大量使用局部变量也会容易造成栈溢出

> 1.全局变量是不可避免要用到的
> >
> > 每一个设备底层几乎都需要它来记录当前状态，控制时序，起承转合。
> > 但是尽量不要用来传递参数，这个很忌讳的。
>
> 2.尽量把变量的作用范围控制在使用它的模块里面
> >
> > - 如果其他模块要访问，就开个读或写函数接口出来，严格控制访问范围。
> > - 这一点，C++的private属性就是这么干的。这对将来程序的调试也很有好处。
> > - C语言之所以有++版本，很大原因就是为了控制它的灵活性，要说面向对象的思想，C语言早已有之，亦可实现。
>
> 3.当一个模块里面的全局变量超过3个(含)时，就用结构体包起来吧。
> >
> > - 要归0便一起归0，省得丢三落四的。
> 4.在函数里面开个静态的全局变量，全局数组，是不占用栈空间的
> >
> > - 静态的 存放在 SRAM; 防止栈爆掉
> 5.程序模型？如何分析抽象出来呢，从哪个角度进行模型构建呢？
> >
> > - 本人一直以来都是从两个角度分析系统，事件--**状态机迁移图** 和 **数据流图**，前者分析控制流向，完善UI，后者可知晓系统数据的缘起缘灭。

## volatile static 用法

### 参考网址

- <https://blog.csdn.net/martinue/article/details/87624342>

### 注意问题

#### static 用法

- 不可重入函数
- 所谓的函数是可重入的（也可以说是可预测的），即：只要输入数据相同就应产生相同的输出。

```
// 这个函数之所以是不可预测的
unsigned int sum_int( unsigned int base )
{
　unsigned int index;
　static unsigned int sum = 0; // 注意，是static类型的。
　for (index = 1; index <= base; index++)
　{
　　sum += index;
　}
　return sum;
}
```

- 将声明sum变量中的static关键字去掉, 函数即变为一个可重入的函数
- 当然，有些时候，在函数中是必须要使用static变量的，比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

#### volatile 用法

- 遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化， 每次都要到变量的地址中去读取变量的数据
- 编译器如何优化变量：
  - 比如： int a=1;  a=2;  a=3; 编译器认为 a=3 才有意义，所以，a = 3 会被暂存，每次用 a 编译器默认用 3，但是 a 可能在中断或多线程被改了，此时，a 依旧等于3，数据就会出错

- 使用 volatile 的场景：
  - 在中断服务中使用的变量，如果不使用 volatile 可能会出现中断中无法改变数据
  - 多任务环境下各任务共享的标志位，或通信数据，或状态机
  - 存储器映射的硬件寄存器，比如 STM32 库函数中的前缀 __I 和 __IO 就是用 volatile

### 一个参数既可以是const还可以是volatile吗？

- 可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。软件不能改变，并不意味着我硬件不能改变你的值，这就是单片机中的应用

#### const 介绍

- 参考网址： http://c.biancheng.net/view/217.html

- const 定义的是变量，但又相当于常量；说它定义的是常量，但又有变量的属性，所以叫常变量
- const 定义的变量的值是不允许改变的，即不允许给它重新赋值
- 用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程
- 经过 const 修饰过的变量存储在内存中的“只读数据段”中

#### const 和 define

- define定义的宏是在预处理阶段展开的； 而const定义的只读变量是在编译运行阶段使用的
- define定义的宏在编译后就不存在了，它不占用内存； const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元
- 编译器可以对 const 进行类型安全检查，而对 define 只是机械地进行字符替换，没有类型安全检查

## 命名规则

### 常用方法

- 常用的命名方法有两种，一种是 Pascal 命名法（帕斯卡命名法），另一种是 Camel 命名法（驼峰命名法）
- Pascal 命名法是指每个单词的首字母大写；Camel 命名法是指第一个单词小写，从第二个单词开始每个单词的首字母大写

### 命名

变量名

- 变量的命名规则遵循 Camel 命名法，例如：studentName
- 全局变量：gSystemCounter
- 局部变量：lMainTimer

常量的命名

- 全部大写，类似宏定义
- 常量： PIR_SET_TIME_SEC_5

类的命名

- 类的命名规则遵循 Pascal 命名法，例如：Student

接口的命名

- 接口的命名规则遵循 Pascal 命名法，通常用 I 开头
- 例如：ICompare

方法的命名

- 方法的命名规则遵循 Pascal 命名法，一般采用动词来命名
- 例如： AddUser